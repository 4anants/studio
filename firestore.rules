/**
 * Core Philosophy: This ruleset enforces a security model based on user ownership and an explicit administrative role. 
 * Standard users have full control over their own data, nested within a user-specific path. A separate, non-public 
 * collection is used to designate administrators, who are granted read-only access to all user data for oversight 
 * and support purposes.
 *
 * Data Structure: The database is organized around a top-level `/users` collection. Each user's profile and their
 * private documents are stored hierarchically under `/users/{employeeId}`. Administrative roles are managed separately 
 * in the `/roles_admin` collection, where the existence of a document signifies admin status.
 *
 * Key Security Decisions:
 * - User data is strictly segregated. A user can only access data under their own `/users/{employeeId}` path.
 * - Listing all users from the top-level `/users` collection is prohibited to prevent enumeration and data leakage.
 * - Administrative privileges are granted via a document in the `/roles_admin` collection. This is more secure and 
 *   performant than relying on a mutable flag on a user's profile.
 * - Admins are granted read-only access to user profiles and documents. They cannot write or delete user data, 
 *   adhering to the principle of least privilege.
 * - The `/roles_admin` collection is not readable by any client, preventing enumeration of administrators. Only 
 *   existing admins can grant or revoke admin status.
 *
 * Denormalization for Authorization: Instead of using a mutable `isAdmin` boolean on a user profile, we use the 
 * existence of a document in `/roles_admin/{userId}`. This allows for a fast, secure, and non-queryable `exists()` 
 * check to determine a user's role anywhere in the ruleset, avoiding costly and complex `get()` calls.
 *
 * Structural Segregation: Each employee's documents are stored in a dedicated subcollection 
 * (`/users/{employeeId}/documents`). This is a secure and performant pattern that physically separates one user's 
 * private data from another's, making security rules simple and efficient.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(employeeId) {
      return isSignedIn() && request.auth.uid == employeeId;
    }

    /**
     * Checks if the requesting user is an administrator.
     * Admin status is determined by the existence of a document in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Ensures an operation is performed by the owner on an existing document.
     * Crucial for preventing unintended writes to non-existent paths.
     */
    function isExistingOwner(employeeId) {
      return isOwner(employeeId) && resource != null;
    }

    /**
     * @description Rules for individual employee profile documents.
     * @path /users/{employeeId}
     * @allow (get) An employee can read their own profile, and an admin can read any profile.
     * @allow (create) An employee can create their own profile document.
     * @deny (list) Listing all employee profiles is disallowed to prevent data leakage.
     * @deny (update) An employee attempting to update another employee's profile.
     * @principle Restricts access to a user's own data tree and allows self-creation of a profile.
     */
    match /users/{employeeId} {
      allow get: if isOwner(employeeId) || isAdmin();
      allow list: if false;
      allow create: if isOwner(employeeId) && request.resource.data.id == employeeId;
      allow update: if isExistingOwner(employeeId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Rules for documents owned by a specific employee.
     * @path /users/{employeeId}/documents/{documentId}
     * @allow (create) An employee can create a document within their own documents subcollection.
     * @allow (list) An employee can list their own documents, and an admin can list any employee's documents.
     * @deny (get) An employee trying to read a document from another employee's subcollection.
     * @deny (delete) An admin trying to delete an employee's document (admins have read-only access).
     * @principle Enforces strict ownership for all write operations and provides admin read-only access.
     */
    match /users/{employeeId}/documents/{documentId} {
      allow get: if isOwner(employeeId) || isAdmin();
      allow list: if isOwner(employeeId) || isAdmin();
      allow create: if isOwner(employeeId) && request.resource.data.employeeId == employeeId;
      allow update: if isExistingOwner(employeeId) && request.resource.data.employeeId == resource.data.employeeId;
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Manages administrator roles. The existence of a document grants admin privileges.
     * @path /roles_admin/{employeeId}
     * @allow (create) An existing admin can create a document to grant another user admin rights.
     * @deny (get) No client can read these documents directly, preventing enumeration of admins.
     * @deny (list) Listing all admin role documents is forbidden.
     * @deny (create) A non-admin user attempting to make themselves an admin.
     * @principle Secures role management by restricting it to existing administrators and preventing discovery.
     */
    match /roles_admin/{employeeId} {
      allow get: if false;
      allow list: if false;
      allow create: if isAdmin();
      allow update: if false;
      allow delete: if isAdmin() && resource != null;
    }
  }
}